/**
 * 

ðŸ”¹ 1. Iterable
An iterable is any object that implements the @@iterator method (a function under the key Symbol.iterator). That method must return an iterator.

âœ… Built-in iterables include:

Arrays

Strings

Sets

Maps

Example: Array as Iterable
js
Copy
Edit
const arr = [10, 20, 30];

const iterator = arr[Symbol.iterator](); // Get the iterator

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
ðŸ”¹ 2. Iterator
An iterator is any object that has a .next() method which returns { value, done }.

Manual Custom Iterator
js
Copy
Edit
const myIterator = {
  data: [1, 2, 3],
  index: 0,
  next() {
    if (this.index < this.data.length) {
      return { value: this.data[this.index++], done: false };
    }
    return { value: undefined, done: true };
  }
};

console.log(myIterator.next()); // { value: 1, done: false }
ðŸ”¹ 3. Generator (Generator Function)
A generator function automatically creates both an iterator and an iterable in one go!

js
Copy
Edit
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = myGenerator();

console.log(typeof gen[Symbol.iterator]); // "function"
console.log(gen === gen[Symbol.iterator]()); // true (it's its own iterable)
ðŸ§  Summary of Relationships
Concept	Has Symbol.iterator?	Has .next()?	Returns values lazily?
Iterable	âœ… Yes	âŒ No	Depends (e.g. arrays = eager)
Iterator	âŒ No	âœ… Yes	âœ… Yes
Generator	âœ… Yes	âœ… Yes	âœ… Yes

âœ… Generators are both iterable and iterators.

ðŸ” Looping Over Iterables
js
Copy
Edit
for (const val of "abc") {
  console.log(val); // 'a', 'b', 'c'
}
Custom iterable example:

js
Copy
Edit
const iterableObject = {
  data: [100, 200, 300],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          return { value: this.data[index++], done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
};

for (const num of iterableObject) {
  console.log(num); // 100, 200, 300
}
ðŸ’¡ Real-Life Use Case Combining All Three
Infinite Range Generator (Lazy Evaluation)
js
Copy
Edit
function* infiniteRange(start = 0) {
  let i = start;
  while (true) {
    yield i++;
  }
}

const numbers = infiniteRange();
console.log(numbers.next().value); // 0
console.log(numbers.next().value); // 1
Used in:

Paginating APIs

Lazy UI loading (like infinite scroll)

Redux-saga

âœ… Quick Recap:
Term	You define it with...	You use it with...
Iterable	Symbol.iterator	for...of, spread (...)
Iterator	.next()	.next() manually
Generator	function* + yield	for...of, .next(), spread

 */


/**
 * 
 * ðŸ”¹ 1. What Are Generators?
Generators are special functions in JavaScript that can pause and resume their execution. They're defined using the function* syntax and use the yield keyword to pause.

Example: Basic Generator
js
Copy
Edit
function* simpleGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = simpleGenerator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
ðŸ”¹ 2. How Generators Work
Key Concepts:
function* defines a generator.

yield pauses the function and returns a value.

next() resumes from the last yield.

ðŸ”¹ 3. Iterating with Generators
Generators are iterable, which means you can use them in loops:

js
Copy
Edit
function* countTo(n) {
  for (let i = 1; i <= n; i++) {
    yield i;
  }
}

for (const num of countTo(5)) {
  console.log(num); // Logs 1 through 5
}
ðŸ”¹ 4. Passing Values Back In
You can send values into a generator via next(value).

js
Copy
Edit
function* greeter() {
  const name = yield "What is your name?";
  yield `Hello, ${name}!`;
}

const greet = greeter();
console.log(greet.next().value);        // "What is your name?"
console.log(greet.next("Krutik").value); // "Hello, Krutik!"
ðŸ”¹ 5. Use Cases in Real Life
âœ… Lazy Evaluation (e.g., large data)
js
Copy
Edit
function* infiniteNumbers() {
  let i = 1;
  while (true) {
    yield i++;
  }
}

const numbers = infiniteNumbers();
console.log(numbers.next().value); // 1
console.log(numbers.next().value); // 2
// Keeps going...
âœ… Generating IDs
js
Copy
Edit
function* idGenerator() {
  let id = 0;
  while (true) {
    yield ++id;
  }
}

const genId = idGenerator();
console.log(genId.next().value); // 1
console.log(genId.next().value); // 2
âœ… Replacing Async/State Machines
js
Copy
Edit
function* fetchSequence() {
  const user = yield fetch("/user").then(res => res.json());
  const posts = yield fetch(`/posts?userId=${user.id}`).then(res => res.json());
  return posts;
}

const it = fetchSequence();
it.next().value.then(user => {
  it.next(user).value.then(posts => {
    console.log(posts);
  });
});
ðŸ”¹ 6. Advanced Tip: Delegating to Other Generators
js
Copy
Edit
function* subGen() {
  yield 'a';
  yield 'b';
}

function* mainGen() {
  yield* subGen();
  yield 'c';
}

for (let val of mainGen()) {
  console.log(val); // a b c
}
ðŸ”¹ 7. When to Use Generators
Infinite data streams

Custom iterators

Pause-resume logic

Implementing coroutines (like async without async/await)

Complex iteration (e.g., tree traversal)

If youâ€™d like, I can guide you through interactive coding exercises or build a real project using generators, like:

A paginated data fetcher

A generator-based Redux Saga-like flow

Lazy list rendering in React
 */